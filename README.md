2025-02-06 16:29

Status:

Tags:

## References 
 [[JavaScript]]

## Notes
[[Python]]3

## Objetivos de Aprendizaje

- Definir la TecnologÃ­a Orientada a Objetos
- Definir la ProgramaciÃ³n Orientada a Objetos (OOP)
- VisiÃ³n general del AnÃ¡lisis y DiseÃ±o Orientado a Objetos (OOAD)
- IntroducciÃ³n a nivel alto sobre Modelado Visual y UML
- Explicar los Conceptos BÃ¡sicos de la OOP
- Aprender y utilizar lo bÃ¡sico de Python suficiente para ilustrar los conceptos de OOP
- Aprender sobre la programaciÃ³n orientada a objetos distribuidos

## Resumen del Curso
### IntroducciÃ³n 
- IntroducciÃ³n a los Conceptos y DiseÃ±o Orientado a Objetos
### Conceptos BÃ¡sicos 
- IntroducciÃ³n a la ProgramaciÃ³n Orientada a Objetos y cÃ³mo se diferencia de la ProgramaciÃ³n Estructurada y Procedimental
### ComprensiÃ³n de la POO 
- Una serie de temas que profundizan en los conceptos de la ProgramaciÃ³n Orientada a Objetos
### Modelado Visual 
- Una visiÃ³n general del Modelado Visual y UML, con Ã©nfasis en el Diagrama de Clases
### Usando AnÃ¡lisis y DiseÃ±o OO 
- Un vistazo a cÃ³mo pasamos de AnÃ¡lisis y DiseÃ±o Orientado a Objetos (OOAD) a la ImplementaciÃ³n
### ProgramaciÃ³n Distribuida 
- Un vistazo a la historia y uso de la ProgramaciÃ³n Distribuida y cÃ³mo se aplica a la POO
### Persistencia 
- ProfundizaciÃ³n en el tema de Almacenamiento de Objetos

## Detalle 
### **1. IntroducciÃ³n a los Conceptos y DiseÃ±o Orientado a Objetos**

- **DescripciÃ³n:** Este tema sirve como una introducciÃ³n general al paradigma de la **ProgramaciÃ³n Orientada a Objetos (POO)** y su importancia en el desarrollo moderno de software.
    - **QuÃ© incluye:**
        - DefiniciÃ³n de POO y sus principios fundamentales.
        - Beneficios de usar POO, como modularidad, reutilizaciÃ³n de cÃ³digo y mantenibilidad.
        - CÃ³mo el diseÃ±o orientado a objetos ayuda a modelar problemas del mundo real en tÃ©rminos de objetos y sus interacciones.
        - Breve introducciÃ³n a conceptos clave como clases, objetos, atributos y mÃ©todos.

---

### **2. IntroducciÃ³n a la ProgramaciÃ³n Orientada a Objetos y cÃ³mo se diferencia de la ProgramaciÃ³n Estructurada y Procedimental**

- **DescripciÃ³n:** AquÃ­ se explica en detalle quÃ© es la POO y cÃ³mo contrasta con otros paradigmas de programaciÃ³n, como la **programaciÃ³n estructurada** y la **programaciÃ³n procedimental** .
    - **QuÃ© incluye:**
        - **ProgramaciÃ³n estructurada/procedimental:**
            - Enfoque basado en funciones o procedimientos.
            - CÃ³digo organizado en secuencias lineales y bloques de lÃ³gica.
            - Limitaciones en cuanto a reutilizaciÃ³n y escalabilidad.
        - **ProgramaciÃ³n orientada a objetos:**
            - Enfoque centrado en objetos que encapsulan datos y comportamientos.
            - Modularidad y organizaciÃ³n del cÃ³digo en clases y objetos.
            - Ventajas sobre la programaciÃ³n estructurada, como mayor flexibilidad y facilidad para manejar sistemas complejos.
        - ComparaciÃ³n prÃ¡ctica entre ambos paradigmas mediante ejemplos.

---

### **3. Una serie de temas que profundizan en los conceptos de la ProgramaciÃ³n Orientada a Objetos**

- **DescripciÃ³n:** Este apartado explora en detalle los conceptos fundamentales y avanzados de POO.
    - **QuÃ© incluye:**
        - **Clases y objetos:**
            - DefiniciÃ³n de clases como plantillas para crear objetos.
            - CreaciÃ³n de instancias de objetos y su uso en programas.
        - **Encapsulamiento:**
            - Ocultamiento de detalles internos de un objeto y exposiciÃ³n solo de lo necesario.
            - Uso de modificadores de acceso (pÃºblico, privado, protegido).
        - **Herencia:**
            - ReutilizaciÃ³n de cÃ³digo mediante la creaciÃ³n de jerarquÃ­as de clases.
            - Clases base y derivadas, y cÃ³mo heredar atributos y mÃ©todos.
        - **Polimorfismo:**
            - Capacidad de objetos de diferentes clases para responder de manera diferente al mismo mensaje o mÃ©todo.
            - Sobrecarga y sobreescritura de mÃ©todos.
        - **Relaciones entre objetos:**
            - ComposiciÃ³n, agregaciÃ³n y asociaciÃ³n.
            - CÃ³mo modelar interacciones entre objetos en un sistema.

---

### **4. Una visiÃ³n general del Modelado Visual y UML, con Ã©nfasis en el Diagrama de Clases**

- **DescripciÃ³n:** Este tema introduce el uso de herramientas de modelado visual, especÃ­ficamente el **Lenguaje Unificado de Modelado (UML)** , para diseÃ±ar sistemas orientados a objetos.
    - **QuÃ© incluye:**
        - **Â¿QuÃ© es UML?**
            - Lenguaje estÃ¡ndar para especificar, construir y documentar sistemas de software.
            - Tipos de diagramas UML: estructurales (clases, objetos) y de comportamiento (secuencia, actividad).
        - **Diagrama de clases:**
            - RepresentaciÃ³n grÃ¡fica de las clases, sus atributos, mÃ©todos y relaciones.
            - NotaciÃ³n bÃ¡sica: rectÃ¡ngulos divididos en tres partes (nombre, atributos, mÃ©todos).
            - Relaciones entre clases: herencia, asociaciÃ³n, composiciÃ³n, agregaciÃ³n.
        - **Aplicaciones prÃ¡cticas:**
            - CÃ³mo utilizar diagramas de clases para planificar sistemas antes de escribir cÃ³digo.
            - Ejemplos de cÃ³mo traducir diagramas UML en cÃ³digo funcional.

---

### **5. Un vistazo a cÃ³mo pasamos de AnÃ¡lisis y DiseÃ±o Orientado a Objetos (OOAD) a la ImplementaciÃ³n**

- **DescripciÃ³n:** Este tema aborda el proceso completo de desarrollo de software, desde el anÃ¡lisis inicial hasta la implementaciÃ³n final.
    - **QuÃ© incluye:**
        - **AnÃ¡lisis orientado a objetos (OOA):**
            - IdentificaciÃ³n de requisitos y modelado del problema mediante objetos.
            - Uso de tÃ©cnicas como tarjetas CRC (Clase, Responsabilidad, Colaborador).
        - **DiseÃ±o orientado a objetos (OOD):**
            - TraducciÃ³n de requisitos en diagramas UML y diseÃ±os detallados.
            - DefiniciÃ³n de clases, atributos, mÃ©todos y relaciones.
        - **ImplementaciÃ³n:**
            - Escritura de cÃ³digo a partir de los diseÃ±os.
            - Pruebas y validaciÃ³n del sistema.
        - **Ejemplos prÃ¡cticos:**
            - CÃ³mo transformar casos de uso en clases y mÃ©todos.
            - Paso a paso desde el diseÃ±o hasta el cÃ³digo funcional.

---

### **6. Un vistazo a la historia y uso de la ProgramaciÃ³n Distribuida y cÃ³mo se aplica a la POO**

- **DescripciÃ³n:** Este tema explora cÃ³mo los conceptos de POO pueden aplicarse en sistemas distribuidos, donde los objetos interactÃºan a travÃ©s de redes.
    - **QuÃ© incluye:**
        - **Historia de la programaciÃ³n distribuida:**
            - EvoluciÃ³n desde sistemas monolÃ­ticos hasta arquitecturas distribuidas.
            - Importancia de la distribuciÃ³n en aplicaciones modernas (microservicios, cloud computing).
        - **Objetos distribuidos:**
            - CÃ³mo llevar objetos a la red y permitir su comunicaciÃ³n remota.
            - Protocolos y tecnologÃ­as utilizadas (RPC, RMI, REST).
        - **Arquitecturas de componentes:**
            - DiseÃ±o de sistemas modulares que interactÃºan entre sÃ­.
            - Componentes distribuidos y su integraciÃ³n en sistemas complejos.
        - **Ejemplos prÃ¡cticos:**
            - Aplicaciones web y mÃ³viles que utilizan objetos distribuidos.
            - Casos de uso en entornos empresariales.

---

### **7. ProfundizaciÃ³n en el tema de Almacenamiento de Objetos**

- **DescripciÃ³n:** Este tema aborda cÃ³mo almacenar objetos de manera persistente, es decir, cÃ³mo guardarlos en bases de datos o archivos para su uso posterior.
    - **QuÃ© incluye:**
        - **Persistencia de objetos:**
            - Necesidad de almacenar el estado de los objetos mÃ¡s allÃ¡ de la ejecuciÃ³n del programa.
            - TÃ©cnicas de serializaciÃ³n y deserializaciÃ³n.
        - **Bases de datos relacionales vs. orientadas a objetos:**
            - Diferencias entre ambos modelos de almacenamiento.
            - Mapeo objeto-relacional (ORM) para trabajar con bases de datos relacionales.
        - **Herramientas y tecnologÃ­as:**
            - Frameworks ORM como Hibernate (Java), SQLAlchemy (Python) o Entity Framework (.NET).
            - Bases de datos NoSQL orientadas a objetos.
        - **Ejemplos prÃ¡cticos:**
            - Guardar y recuperar objetos en una base de datos.
            - Manejo de transacciones y concurrencia en sistemas persistentes.
              
# Repaso 

---

## **1. Conceptos de la ProgramaciÃ³n Orientada a Objetos**

La **ProgramaciÃ³n Orientada a Objetos (POO)** es un paradigma de programaciÃ³n que se basa en el uso de **objetos** para modelar problemas del mundo real. Los objetos encapsulan tanto **datos** (atributos) como **comportamientos** (mÃ©todos). A continuaciÃ³n, se describen los conceptos clave:

---

### **2. Encapsulamiento**
**DefiniciÃ³n:**
El **encapsulamiento** es el principio por el cual los datos (atributos) y comportamientos (mÃ©todos) de un objeto estÃ¡n "ocultos" dentro de la clase. Esto permite proteger la integridad de los datos y controlar cÃ³mo se accede a ellos.

**CaracterÃ­sticas:**
- Los atributos pueden ser **privados**, **protegidos** o **pÃºblicos**.
- Se utilizan mÃ©todos **getters** y **setters** para acceder y modificar atributos privados.

**Ejemplo en Python:**
```python
class CuentaBancaria:
    def __init__(self, saldo):
        self.__saldo = saldo  # Atributo privado

    def depositar(self, cantidad):
        if cantidad > 0:
            self.__saldo += cantidad

    def retirar(self, cantidad):
        if cantidad > 0 and cantidad <= self.__saldo:
            self.__saldo -= cantidad

    def mostrar_saldo(self):
        return self.__saldo


cuenta = CuentaBancaria(1000)
cuenta.depositar(500)
print(cuenta.mostrar_saldo())  # Salida: 1500
```

**Beneficios:**
- Protege los datos internos del objeto.
- Facilita el mantenimiento del cÃ³digo al centralizar el acceso a los atributos.

---

### **3. AbstracciÃ³n**
La abstracciÃ³n es el concepto por el que un modelo es creado con las propiedades relevantes a observar. Un programa trata Ãºnicamente con las propiedades de un objeto que al programa le interesa. Las clases son la abstracciÃ³n de los conceptos que maneja la aplicaciÃ³n, pueden ser conceptos que existan en el mundo real pero simplificados al tener Ãºnicamente las propiedades relevantes para la aplicaciÃ³n. Las clases tambiÃ©n pueden ser conceptos que no tengan una existencia fÃ­sica en el mundo real como una lista de elementos, una direcciÃ³n IP o un archivo de ordenador.

Un aviÃ³n es un objeto fÃ­sico del mundo real con multitud de propiedades, desde su fabricante y modelo, color, tamaÃ±o, numero de asientos, ubicaciÃ³n, capacidad de carga, peso, aÃ±o de diseÃ±o y fabricaciÃ³n, materiales de fabricaciÃ³n, altitud, posiciÃ³n GPS, direcciÃ³n, velocidad y distancia mÃ¡xima y muchas otras. De todas estas propiedades en una aplicaciÃ³n de gestiÃ³n de embarque le interesarÃ¡ Ãºnicamente las propiedades de los asientos, quizÃ¡ en otra aplicaciÃ³n para la programaciÃ³n de vuelo le interesa otras propiedades como altitud, posiciÃ³n GPS, direcciÃ³n, velocidad aeropuerto origen y destino o distancia.

---

### **4. Objeto, Clase e Instancia**
**Definiciones:**
- **Clase:** Es una plantilla o molde que define las caracterÃ­sticas (atributos) y comportamientos (mÃ©todos) que tendrÃ¡n los objetos creados a partir de ella.
- **Objeto:** Es una instancia concreta de una clase. Representa algo del mundo real.
- **Instancia:** Es el proceso de crear un objeto a partir de una clase.

**Ejemplo en Python:**
```python
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saludar(self):
        print(f"Hola, soy {self.nombre} y tengo {self.edad} aÃ±os.")


persona1 = Persona("Juan", 25)  # CreaciÃ³n de una instancia
persona1.saludar()  # Salida: Hola, soy Juan y tengo 25 aÃ±os.
```

**Diferencia entre Clase y Objeto:**
- Una **clase** es como un plano o diseÃ±o.
- Un **objeto** es una casa construida a partir de ese plano.

---

### **5. Herencia e Interfaces**
**Herencia:**
- La **herencia** permite que una clase (subclase) reutilice y extienda el comportamiento de otra clase (superclase).
- Promueve la reutilizaciÃ³n de cÃ³digo y la jerarquÃ­a.

**Interfaces:**
- Las **interfaces** definen un contrato que las subclases deben cumplir. No contienen implementaciÃ³n, solo declaran mÃ©todos.

**Ejemplo de Herencia en Python:**
```python
class Vehiculo:
    def mover(self):
        print("Moviendo vehÃ­culo...")


class Coche(Vehiculo):
    def mover(self):
        print("Conduciendo coche...")


class Motocicleta(Vehiculo):
    def mover(self):
        print("Manejando motocicleta...")
```

**Ejemplo de Interfaces en Python:**
```python
from abc import ABC, abstractmethod

class Volador(ABC):
    @abstractmethod
    def volar(self):
        pass


class Avion(Volador):
    def volar(self):
        print("Volando en aviÃ³n...")


class Helicoptero(Volador):
    def volar(self):
        print("Volando en helicÃ³ptero...")
```

---

### **6. Polimorfismo**
**DefiniciÃ³n:**
El **polimorfismo** permite que objetos de diferentes clases respondan de manera diferente al mismo mensaje o mÃ©todo. Esto se logra mediante la sobrecarga o sobreescritura de mÃ©todos.

**Ejemplo en Python:**
```python
def hacer_volar(volador):
    volador.volar()


avion = Avion()
helicoptero = Helicoptero()

hacer_volar(avion)       # Salida: Volando en aviÃ³n...
hacer_volar(helicoptero)  # Salida: Volando en helicÃ³ptero...
```

**Beneficios:**
- Mejora la flexibilidad del cÃ³digo.
- Permite escribir funciones genÃ©ricas que funcionen con diferentes tipos de objetos.

---

### **7. Los Problemas de la Herencia**
**Problemas Comunes:**
1. **Fragilidad:** Si la superclase cambia, puede romper todas las subclases.
2. **Complejidad:** JerarquÃ­as profundas de herencia pueden ser difÃ­ciles de mantener.
3. **Rigidez:** La herencia puede limitar la flexibilidad del diseÃ±o.

**Alternativa: Preferir ComposiciÃ³n sobre Herencia.**

---

### **8. ComposiciÃ³n**
**DefiniciÃ³n:**
La **composiciÃ³n** es un principio que sugiere que los objetos deben estar compuestos por otros objetos en lugar de heredar de ellos. Es decir, "tiene un" en lugar de "es un".

**Ejemplo en Python:**
```python
class Motor:
    def encender(self):
        print("Motor encendido.")


class Coche:
    def __init__(self):
        self.motor = Motor()  # ComposiciÃ³n

    def arrancar(self):
        self.motor.encender()
        print("Coche arrancado.")


coche = Coche()
coche.arrancar()
```

---

### **9. Beneficios de la ComposiciÃ³n**
4. **Flexibilidad:** Es mÃ¡s fÃ¡cil cambiar o reemplazar componentes individuales.
5. **ReutilizaciÃ³n:** Los componentes pueden ser reutilizados en diferentes contextos.
6. **Simplicidad:** Evita jerarquÃ­as complejas de herencia.

---

### **Resumen Final**
| **Concepto**         | **DescripciÃ³n**                                                                 |
|-----------------------|---------------------------------------------------------------------------------|
| **Encapsulamiento**   | Oculta los detalles internos y protege los datos.                              |
| **AbstracciÃ³n**       | Simplifica el diseÃ±o al exponer solo lo esencial.                              |
| **Objeto/Clase**      | Un objeto es una instancia de una clase, que es una plantilla para crear objetos.|
| **Herencia**          | Permite reutilizar y extender el comportamiento de una clase.                  |
| **Polimorfismo**      | Permite que objetos diferentes respondan de manera distinta al mismo mensaje.  |
| **ComposiciÃ³n**       | Combina objetos en lugar de heredar de ellos, mejorando la flexibilidad.       |

Â¡Espero que esta guÃ­a te sea Ãºtil para enseÃ±ar los conceptos de POO de manera clara y efectiva! ğŸš€
## Â¿QuÃ© es OOP?
- OPP es Object-Oriented Programming
- Requiere que el desarrollador piense en la soluciÃ³n del software de manera distinta
- Requiere el uso de un lenguaje orientado a objetos
## Beneficios de la ProgramaciÃ³n Orientada a Objetos (OO)

- Los objetos reflejan entidades reales del mundo real 
- Impulsa arquitectura, diseÃ±o y reusabilidad de cÃ³digo
- Promueve comunicaciÃ³n consistente en temas tÃ©cnicos entre negocios y equipos tÃ©cnicos
- Construye sistemas que son mÃ¡s fÃ¡ciles de expandir o modificar
- Promueve soluciones de alta calidad
- Funciona para sistemas de software grandes y complejos
## Lenguajes orientados a OOP

- Java
- Python
- C++
- JavaScript - TypeScript
- C#

# DiseÃ±o para la OOP

[[S.O.L.I.D.]]

OOAD (Object-Oriented Analysis and Design)
Object-Oriented Analysis se enfoca en encontrar y describir objetos o conceptos en el dominio del problema

### OO (Orientado a Objetos) enfoque al diseÃ±o
- Definir y detallar los objetos perteneciente al software 
- Como interactÃºan los objetos del software para cumplir con los requisitos

#### TÃ©cnica de diseÃ±o
Las **tarjetas CRC** (Clase-Responsabilidad-ColaboraciÃ³n) son una tÃ©cnica de diseÃ±o en la programaciÃ³n orientada a objetos, desarrollada por **Ward Cunningham** y **Kent Beck**. Esta metodologÃ­a se utiliza para identificar y organizar las clases que formarÃ¡n parte de un sistema, facilitando la comprensiÃ³n y estructuraciÃ³n del mismo.

Cada tarjeta CRC representa una clase y se divide en tres secciones:

7. **Clase**: Nombre de la clase.
8. **Responsabilidad**: Funciones o comportamientos que la clase debe cumplir.
9. **ColaboraciÃ³n**: Otras clases con las que interactÃºa para cumplir sus responsabilidades.

Durante una sesiÃ³n de diseÃ±o con tarjetas CRC, los participantes crean tarjetas para cada clase identificada y definen sus responsabilidades y colaboraciones. Este enfoque promueve una comprensiÃ³n clara de cÃ³mo interactÃºan las diferentes partes del sistema y ayuda a detectar posibles problemas en la arquitectura antes de la implementaciÃ³n.

## Principios Clave de la ProgramaciÃ³n Orientada a Objetos

â–¸ La programaciÃ³n orientada a objetos se centra en los **objetos individuales y sus datos**.  
â–¸ Los sistemas orientados a objetos nos permiten ver un sistema como objetos que **encapsulan** estado y comportamiento.  
â–¸ Los modelos de diseÃ±o orientados a objetos se **desarrollan cerca de la implementaciÃ³n**. 
â–¸ Los sistemas orientados a objetos fomentan la **reutilizaciÃ³n** de elementos de programaciÃ³n.

## Cualidades de un Sistema Orientado a Objetos (OO System)

### Reusabilidad
- Habilidad para crear y reutilizar componentes arquitectÃ³nicos de un sistema.
- Reducir la redundancia en el desarrollo al crear o adquirir framworks, componentes o servicios reutilizables.
- Los componentes pueden ser reutilizados en mÃºiltiples proyectos.
- Aprovechar la experiencia de expertos en el dominio para la soluciÃ³n del desarrollo.
### Confiabilidad (Reliability)
Al reutilizar los componentes tambiÃ©n disponemos de mÃ¡s tiempo para mantenerlos actualizados.
Los componentes estÃ¡n aislados de otros componentes del sistema. Por lo tanto al modificarlos no se afectan las otras piezas.
### Robustez 
La habilidad de un sistema para mantenerse operando correctamente bajo un rango de condiciones operacionales y fallar de manera controlada y anticipada en las condiciones fuera de tal rango.
El sistema debe ser capaz de funcionar a pesar de las condiciones.
El proceso de desarrollo OO estÃ¡ diseÃ±ado para que el equipo tÃ©cnico desarrolle aplicaciones totalmente funcionales usando anÃ¡lisis preciso, diseÃ±o y tÃ©cnicas de codificaciÃ³n
En tanto que el sistema evoluciona se debe aplicar testeo para verificar la robustez.
Se testea cada parte del sistema de manera desacoplada.
### Extensibilidad
La habilidad de aÃ±adir nuevos features (CaracterÃ­sticas o funcionalidades) a un programa sin alterar cÃ³digo existente.
Esto se logra creando objetos modulares y componentes que pueden ser alterados o mejorados sin alterar otras partes de la aplicaciÃ³n.

### Mantenibilidad
La facilidad con la que cada sistema o componente puede ser modificado para corregir faltas, mejorar rendimiento o algÃºn otro atributo. AsÃ­ como adaptar a un ambiente que cambia.
Un buen diseÃ±o de OO permite modificar mÃ³dulos sin afectar al sistema completo.


# Principios S.O.L.I.D.

Los **principios SOLID** son un conjunto de cinco principios de diseÃ±o en la programaciÃ³n orientada a objetos (POO) que buscan hacer que el software sea mÃ¡s **mantenible**, **escalable** y **flexible**. Estos principios fueron introducidos por **Robert C. Martin** (tambiÃ©n conocido como "Uncle Bob") y son ampliamente utilizados en el desarrollo de software moderno.

A continuaciÃ³n, te explico cada uno de los principios SOLID con ejemplos claros:

---

### **1. S - Single Responsibility Principle (SRP)**  
**Principio de Responsabilidad Ãšnica**

**DefiniciÃ³n:**  
Una clase debe tener una Ãºnica razÃ³n para cambiar, es decir, debe tener una sola responsabilidad o tarea bien definida.

**Ejemplo:**
Imagina una clase `Informe` que genera un informe y lo guarda en un archivo:

```python
class Informe:
    def generar_informe(self, datos):
        return f"Informe: {datos}"

    def guardar_en_archivo(self, contenido, nombre_archivo):
        with open(nombre_archivo, 'w') as archivo:
            archivo.write(contenido)
```

**Problema:** La clase tiene dos responsabilidades: generar el informe y guardarlo en un archivo. Esto viola el SRP.

**SoluciÃ³n:** Dividir las responsabilidades en dos clases diferentes.

```python
class GeneradorInforme:
    def generar_informe(self, datos):
        return f"Informe: {datos}"

class GuardadorArchivo:
    def guardar_en_archivo(self, contenido, nombre_archivo):
        with open(nombre_archivo, 'w') as archivo:
            archivo.write(contenido)
```

Ahora cada clase tiene una Ãºnica responsabilidad.

---

### **2. O - Open/Closed Principle (OCP)**  
**Principio de Abierto/Cerrado**

**DefiniciÃ³n:**  
Las entidades de software (clases, mÃ³dulos, funciones) deben estar **abiertas para extensiÃ³n**, pero **cerradas para modificaciÃ³n**. Es decir, puedes agregar nuevas funcionalidades sin modificar el cÃ³digo existente.

**Ejemplo:**
Supongamos que tienes una clase `CalculadoraArea` que calcula el Ã¡rea de figuras geomÃ©tricas:

```python
class CalculadoraArea:
    def calcular_area(self, figura):
        if figura == "circulo":
            return 3.14 * radio ** 2
        elif figura == "cuadrado":
            return lado ** 2
```

**Problema:** Si quieres agregar una nueva figura (por ejemplo, triÃ¡ngulo), necesitas modificar la clase existente, lo cual viola el OCP.

**SoluciÃ³n:** Usar herencia y polimorfismo.

```python
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def calcular_area(self):
        pass

class Circulo(Figura):
    def __init__(self, radio):
        self.radio = radio

    def calcular_area(self):
        return 3.14 * self.radio ** 2

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado

    def calcular_area(self):
        return self.lado ** 2

# Ahora puedes agregar nuevas figuras sin modificar la clase base.
```

---

### **3. L - Liskov Substitution Principle (LSP)**  
**Principio de SustituciÃ³n de Liskov**

**DefiniciÃ³n:**  
Los objetos de una clase derivada (subclase) deben poder sustituirse por objetos de la clase base (superclase) sin alterar el comportamiento del programa.

**Ejemplo:**
Supongamos que tienes una clase `Ave` con un mÃ©todo `volar()`:

```python
class Ave:
    def volar(self):
        print("Volando...")

class Pinguino(Ave):
    def volar(self):
        raise Exception("Los pingÃ¼inos no pueden volar")
```

**Problema:** Al intentar usar un objeto `Pinguino` donde se espera un `Ave`, el programa fallarÃ¡ porque los pingÃ¼inos no vuelan.

**SoluciÃ³n:** Separar las responsabilidades.

```python
class Ave:
    pass

class AveVoladora(Ave):
    def volar(self):
        print("Volando...")

class AveNoVoladora(Ave):
    pass

class Pinguino(AveNoVoladora):
    pass
```

Ahora, los pingÃ¼inos no rompen el principio LSP porque no se espera que vuelen.

---

### **4. I - Interface Segregation Principle (ISP)**  
**Principio de SegregaciÃ³n de Interfaces**

**DefiniciÃ³n:**  
Es mejor tener interfaces pequeÃ±as y especÃ­ficas en lugar de una interfaz grande y general. Los clientes no deben depender de interfaces que no usan.

**Ejemplo:**
Supongamos que tienes una interfaz `Trabajador` que incluye mÃ©todos como `trabajar()`, `comer()` y `dormir()`:

```python
class Trabajador:
    def trabajar(self):
        pass

    def comer(self):
        pass

    def dormir(self):
        pass
```

**Problema:** No todos los trabajadores comen o duermen en el trabajo (por ejemplo, robots).

**SoluciÃ³n:** Dividir la interfaz en interfaces mÃ¡s pequeÃ±as.

```python
class Trabajador:
    def trabajar(self):
        pass

class Comedor:
    def comer(self):
        pass

class Durmiente:
    def dormir(self):
        pass
```

Ahora, cada clase puede implementar solo las interfaces que necesita.

---

### **5. D - Dependency Inversion Principle (DIP)**  
**Principio de InversiÃ³n de Dependencias**

**DefiniciÃ³n:**  
Las clases de alto nivel no deben depender de clases de bajo nivel. Ambas deben depender de abstracciones. AdemÃ¡s, las abstracciones no deben depender de detalles; los detalles deben depender de abstracciones.

**Ejemplo:**
Supongamos que tienes una clase `ControladorLuces` que depende directamente de una clase `Bombilla`:

```python
class Bombilla:
    def encender(self):
        print("Bombilla encendida")

class ControladorLuces:
    def __init__(self):
        self.bombilla = Bombilla()

    def operar(self):
        self.bombilla.encender()
```

**Problema:** Si quieres cambiar la bombilla por un LED, necesitas modificar la clase `ControladorLuces`.

**SoluciÃ³n:** Usar una interfaz abstracta.

```python
from abc import ABC, abstractmethod

class DispositivoEncendido(ABC):
    @abstractmethod
    def encender(self):
        pass

class Bombilla(DispositivoEncendido):
    def encender(self):
        print("Bombilla encendida")

class LED(DispositivoEncendido):
    def encender(self):
        print("LED encendido")

class ControladorLuces:
    def __init__(self, dispositivo: DispositivoEncendido):
        self.dispositivo = dispositivo

    def operar(self):
        self.dispositivo.encender()
```

Ahora, `ControladorLuces` depende de una abstracciÃ³n (`DispositivoEncendido`) en lugar de una implementaciÃ³n especÃ­fica.

---

### **Resumen de los Principios SOLID**

| **Principio** | **Significado**                                                                 |
|---------------|---------------------------------------------------------------------------------|
| **S**         | Una clase debe tener una Ãºnica responsabilidad.                                |
| **O**         | Las clases deben ser abiertas para extensiÃ³n, pero cerradas para modificaciÃ³n. |
| **L**         | Las subclases deben poder reemplazar a las superclases sin alterar el programa.|
| **I**         | Preferir interfaces pequeÃ±as y especÃ­ficas en lugar de interfaces grandes.     |
| **D**         | Depender de abstracciones, no de implementaciones.                             |

---

### **Beneficios de Aplicar SOLID**
1. **Mantenibilidad:** El cÃ³digo es mÃ¡s fÃ¡cil de mantener y modificar.
2. **Escalabilidad:** Es mÃ¡s sencillo agregar nuevas funcionalidades sin romper el sistema.
3. **ReutilizaciÃ³n:** Las clases y mÃ³dulos son mÃ¡s reutilizables en diferentes contextos.
4. **Flexibilidad:** El sistema es mÃ¡s adaptable a cambios futuros.

# Conceptos bÃ¡sicos de la programaciÃ³n OO
- Objetos 
- Encapsulamiento
- Mensajes
- AbstracciÃ³n
- Polimorfismo
- Herencia
Un software OO consiste en un grupo de objetos bien definidos que aprovechan la Encapsulamiento y se comunican entre ellos mediante mensajes.
### Objetos
- Entidad o concepto en la soluciÃ³n de software
- Bloques individuales de nuestra soluciÃ³n de software
- Tiene estados o datos (en forma de variables)
- Tiene un comportamiento (en forma de funciones)
- Es una instancia de un tipo de dato abstracto
 ![[Pasted image 20250207221931.png]]
### AbstracciÃ³n
- Los objetos representan abstracciones de un concepto real y solo maneja datos y operaciones relevantes para nuestro caso de uso.
- Posibilidad de extensiÃ³n en caso de ser necesaria.
### Herencia
- Podemos crear jerarquÃ­as de objetos donde las clases superiores manejan una base y sus herederas se especializan con nuevas y Ãºnicas caracterÃ­sticas requeridas para el programa.
### Encapsulamiento 
- Empaquetar los datos con sus mÃ©todos correspondientes
- TÃ©cnica para ocultar datos
### Mensaje 
- SeÃ±al de un objeto hacia otro
- PeticiÃ³n hacia el objeto que recibe el mensaje para ejecutar un mÃ©todo
- Los lenguajes de programaciÃ³n utilizan funciones call
### Polimorfismo
- El mismo mensaje puede ser enviado a mÃºltiples receptores y todos van a reaccionar segÃºn su programaciÃ³n de manera Ãºnica

# Contraste de la metodologÃ­a OO con la metodologÃ­a estructurada - VisiÃ³n general
![[Pasted image 20250207224035.png]]
![[Pasted image 20250207225121.png]]
![[Pasted image 20250207225200.png]]

![[Pasted image 20250207225222.png]]
![[Pasted image 20250207225246.png]]

![[Pasted image 20250207225318.png]]
![[Pasted image 20250207224552.png]]

# Cuestionario
![[Pasted image 20250207224915.png]]![[Pasted image 20250207224932.png]]![[Pasted image 20250207225007.png]]
![[Pasted image 20250207225500.png]]
