2025-02-06 16:29

Status:

Tags:

## References 
 [[JavaScript]]

## Notes
[[Python]]3

## Objetivos de Aprendizaje

- Definir la Tecnología Orientada a Objetos
- Definir la Programación Orientada a Objetos (OOP)
- Visión general del Análisis y Diseño Orientado a Objetos (OOAD)
- Introducción a nivel alto sobre Modelado Visual y UML
- Explicar los Conceptos Básicos de la OOP
- Aprender y utilizar lo básico de Python suficiente para ilustrar los conceptos de OOP
- Aprender sobre la programación orientada a objetos distribuidos

## Resumen del Curso
### Introducción 
- Introducción a los Conceptos y Diseño Orientado a Objetos
### Conceptos Básicos 
- Introducción a la Programación Orientada a Objetos y cómo se diferencia de la Programación Estructurada y Procedimental
### Comprensión de la POO 
- Una serie de temas que profundizan en los conceptos de la Programación Orientada a Objetos
### Modelado Visual 
- Una visión general del Modelado Visual y UML, con énfasis en el Diagrama de Clases
### Usando Análisis y Diseño OO 
- Un vistazo a cómo pasamos de Análisis y Diseño Orientado a Objetos (OOAD) a la Implementación
### Programación Distribuida 
- Un vistazo a la historia y uso de la Programación Distribuida y cómo se aplica a la POO
### Persistencia 
- Profundización en el tema de Almacenamiento de Objetos

## Detalle 
### **1. Introducción a los Conceptos y Diseño Orientado a Objetos**

- **Descripción:** Este tema sirve como una introducción general al paradigma de la **Programación Orientada a Objetos (POO)** y su importancia en el desarrollo moderno de software.
    - **Qué incluye:**
        - Definición de POO y sus principios fundamentales.
        - Beneficios de usar POO, como modularidad, reutilización de código y mantenibilidad.
        - Cómo el diseño orientado a objetos ayuda a modelar problemas del mundo real en términos de objetos y sus interacciones.
        - Breve introducción a conceptos clave como clases, objetos, atributos y métodos.

---

### **2. Introducción a la Programación Orientada a Objetos y cómo se diferencia de la Programación Estructurada y Procedimental**

- **Descripción:** Aquí se explica en detalle qué es la POO y cómo contrasta con otros paradigmas de programación, como la **programación estructurada** y la **programación procedimental** .
    - **Qué incluye:**
        - **Programación estructurada/procedimental:**
            - Enfoque basado en funciones o procedimientos.
            - Código organizado en secuencias lineales y bloques de lógica.
            - Limitaciones en cuanto a reutilización y escalabilidad.
        - **Programación orientada a objetos:**
            - Enfoque centrado en objetos que encapsulan datos y comportamientos.
            - Modularidad y organización del código en clases y objetos.
            - Ventajas sobre la programación estructurada, como mayor flexibilidad y facilidad para manejar sistemas complejos.
        - Comparación práctica entre ambos paradigmas mediante ejemplos.

---

### **3. Una serie de temas que profundizan en los conceptos de la Programación Orientada a Objetos**

- **Descripción:** Este apartado explora en detalle los conceptos fundamentales y avanzados de POO.
    - **Qué incluye:**
        - **Clases y objetos:**
            - Definición de clases como plantillas para crear objetos.
            - Creación de instancias de objetos y su uso en programas.
        - **Encapsulamiento:**
            - Ocultamiento de detalles internos de un objeto y exposición solo de lo necesario.
            - Uso de modificadores de acceso (público, privado, protegido).
        - **Herencia:**
            - Reutilización de código mediante la creación de jerarquías de clases.
            - Clases base y derivadas, y cómo heredar atributos y métodos.
        - **Polimorfismo:**
            - Capacidad de objetos de diferentes clases para responder de manera diferente al mismo mensaje o método.
            - Sobrecarga y sobreescritura de métodos.
        - **Relaciones entre objetos:**
            - Composición, agregación y asociación.
            - Cómo modelar interacciones entre objetos en un sistema.

---

### **4. Una visión general del Modelado Visual y UML, con énfasis en el Diagrama de Clases**

- **Descripción:** Este tema introduce el uso de herramientas de modelado visual, específicamente el **Lenguaje Unificado de Modelado (UML)** , para diseñar sistemas orientados a objetos.
    - **Qué incluye:**
        - **¿Qué es UML?**
            - Lenguaje estándar para especificar, construir y documentar sistemas de software.
            - Tipos de diagramas UML: estructurales (clases, objetos) y de comportamiento (secuencia, actividad).
        - **Diagrama de clases:**
            - Representación gráfica de las clases, sus atributos, métodos y relaciones.
            - Notación básica: rectángulos divididos en tres partes (nombre, atributos, métodos).
            - Relaciones entre clases: herencia, asociación, composición, agregación.
        - **Aplicaciones prácticas:**
            - Cómo utilizar diagramas de clases para planificar sistemas antes de escribir código.
            - Ejemplos de cómo traducir diagramas UML en código funcional.

---

### **5. Un vistazo a cómo pasamos de Análisis y Diseño Orientado a Objetos (OOAD) a la Implementación**

- **Descripción:** Este tema aborda el proceso completo de desarrollo de software, desde el análisis inicial hasta la implementación final.
    - **Qué incluye:**
        - **Análisis orientado a objetos (OOA):**
            - Identificación de requisitos y modelado del problema mediante objetos.
            - Uso de técnicas como tarjetas CRC (Clase, Responsabilidad, Colaborador).
        - **Diseño orientado a objetos (OOD):**
            - Traducción de requisitos en diagramas UML y diseños detallados.
            - Definición de clases, atributos, métodos y relaciones.
        - **Implementación:**
            - Escritura de código a partir de los diseños.
            - Pruebas y validación del sistema.
        - **Ejemplos prácticos:**
            - Cómo transformar casos de uso en clases y métodos.
            - Paso a paso desde el diseño hasta el código funcional.

---

### **6. Un vistazo a la historia y uso de la Programación Distribuida y cómo se aplica a la POO**

- **Descripción:** Este tema explora cómo los conceptos de POO pueden aplicarse en sistemas distribuidos, donde los objetos interactúan a través de redes.
    - **Qué incluye:**
        - **Historia de la programación distribuida:**
            - Evolución desde sistemas monolíticos hasta arquitecturas distribuidas.
            - Importancia de la distribución en aplicaciones modernas (microservicios, cloud computing).
        - **Objetos distribuidos:**
            - Cómo llevar objetos a la red y permitir su comunicación remota.
            - Protocolos y tecnologías utilizadas (RPC, RMI, REST).
        - **Arquitecturas de componentes:**
            - Diseño de sistemas modulares que interactúan entre sí.
            - Componentes distribuidos y su integración en sistemas complejos.
        - **Ejemplos prácticos:**
            - Aplicaciones web y móviles que utilizan objetos distribuidos.
            - Casos de uso en entornos empresariales.

---

### **7. Profundización en el tema de Almacenamiento de Objetos**

- **Descripción:** Este tema aborda cómo almacenar objetos de manera persistente, es decir, cómo guardarlos en bases de datos o archivos para su uso posterior.
    - **Qué incluye:**
        - **Persistencia de objetos:**
            - Necesidad de almacenar el estado de los objetos más allá de la ejecución del programa.
            - Técnicas de serialización y deserialización.
        - **Bases de datos relacionales vs. orientadas a objetos:**
            - Diferencias entre ambos modelos de almacenamiento.
            - Mapeo objeto-relacional (ORM) para trabajar con bases de datos relacionales.
        - **Herramientas y tecnologías:**
            - Frameworks ORM como Hibernate (Java), SQLAlchemy (Python) o Entity Framework (.NET).
            - Bases de datos NoSQL orientadas a objetos.
        - **Ejemplos prácticos:**
            - Guardar y recuperar objetos en una base de datos.
            - Manejo de transacciones y concurrencia en sistemas persistentes.
              
# Repaso 

---

## **1. Conceptos de la Programación Orientada a Objetos**

La **Programación Orientada a Objetos (POO)** es un paradigma de programación que se basa en el uso de **objetos** para modelar problemas del mundo real. Los objetos encapsulan tanto **datos** (atributos) como **comportamientos** (métodos). A continuación, se describen los conceptos clave:

---

### **2. Encapsulamiento**
**Definición:**
El **encapsulamiento** es el principio por el cual los datos (atributos) y comportamientos (métodos) de un objeto están "ocultos" dentro de la clase. Esto permite proteger la integridad de los datos y controlar cómo se accede a ellos.

**Características:**
- Los atributos pueden ser **privados**, **protegidos** o **públicos**.
- Se utilizan métodos **getters** y **setters** para acceder y modificar atributos privados.

**Ejemplo en Python:**
```python
class CuentaBancaria:
    def __init__(self, saldo):
        self.__saldo = saldo  # Atributo privado

    def depositar(self, cantidad):
        if cantidad > 0:
            self.__saldo += cantidad

    def retirar(self, cantidad):
        if cantidad > 0 and cantidad <= self.__saldo:
            self.__saldo -= cantidad

    def mostrar_saldo(self):
        return self.__saldo


cuenta = CuentaBancaria(1000)
cuenta.depositar(500)
print(cuenta.mostrar_saldo())  # Salida: 1500
```

**Beneficios:**
- Protege los datos internos del objeto.
- Facilita el mantenimiento del código al centralizar el acceso a los atributos.

---

### **3. Abstracción**
La abstracción es el concepto por el que un modelo es creado con las propiedades relevantes a observar. Un programa trata únicamente con las propiedades de un objeto que al programa le interesa. Las clases son la abstracción de los conceptos que maneja la aplicación, pueden ser conceptos que existan en el mundo real pero simplificados al tener únicamente las propiedades relevantes para la aplicación. Las clases también pueden ser conceptos que no tengan una existencia física en el mundo real como una lista de elementos, una dirección IP o un archivo de ordenador.

Un avión es un objeto físico del mundo real con multitud de propiedades, desde su fabricante y modelo, color, tamaño, numero de asientos, ubicación, capacidad de carga, peso, año de diseño y fabricación, materiales de fabricación, altitud, posición GPS, dirección, velocidad y distancia máxima y muchas otras. De todas estas propiedades en una aplicación de gestión de embarque le interesará únicamente las propiedades de los asientos, quizá en otra aplicación para la programación de vuelo le interesa otras propiedades como altitud, posición GPS, dirección, velocidad aeropuerto origen y destino o distancia.

---

### **4. Objeto, Clase e Instancia**
**Definiciones:**
- **Clase:** Es una plantilla o molde que define las características (atributos) y comportamientos (métodos) que tendrán los objetos creados a partir de ella.
- **Objeto:** Es una instancia concreta de una clase. Representa algo del mundo real.
- **Instancia:** Es el proceso de crear un objeto a partir de una clase.

**Ejemplo en Python:**
```python
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saludar(self):
        print(f"Hola, soy {self.nombre} y tengo {self.edad} años.")


persona1 = Persona("Juan", 25)  # Creación de una instancia
persona1.saludar()  # Salida: Hola, soy Juan y tengo 25 años.
```

**Diferencia entre Clase y Objeto:**
- Una **clase** es como un plano o diseño.
- Un **objeto** es una casa construida a partir de ese plano.

---

### **5. Herencia e Interfaces**
**Herencia:**
- La **herencia** permite que una clase (subclase) reutilice y extienda el comportamiento de otra clase (superclase).
- Promueve la reutilización de código y la jerarquía.

**Interfaces:**
- Las **interfaces** definen un contrato que las subclases deben cumplir. No contienen implementación, solo declaran métodos.

**Ejemplo de Herencia en Python:**
```python
class Vehiculo:
    def mover(self):
        print("Moviendo vehículo...")


class Coche(Vehiculo):
    def mover(self):
        print("Conduciendo coche...")


class Motocicleta(Vehiculo):
    def mover(self):
        print("Manejando motocicleta...")
```

**Ejemplo de Interfaces en Python:**
```python
from abc import ABC, abstractmethod

class Volador(ABC):
    @abstractmethod
    def volar(self):
        pass


class Avion(Volador):
    def volar(self):
        print("Volando en avión...")


class Helicoptero(Volador):
    def volar(self):
        print("Volando en helicóptero...")
```

---

### **6. Polimorfismo**
**Definición:**
El **polimorfismo** permite que objetos de diferentes clases respondan de manera diferente al mismo mensaje o método. Esto se logra mediante la sobrecarga o sobreescritura de métodos.

**Ejemplo en Python:**
```python
def hacer_volar(volador):
    volador.volar()


avion = Avion()
helicoptero = Helicoptero()

hacer_volar(avion)       # Salida: Volando en avión...
hacer_volar(helicoptero)  # Salida: Volando en helicóptero...
```

**Beneficios:**
- Mejora la flexibilidad del código.
- Permite escribir funciones genéricas que funcionen con diferentes tipos de objetos.

---

### **7. Los Problemas de la Herencia**
**Problemas Comunes:**
1. **Fragilidad:** Si la superclase cambia, puede romper todas las subclases.
2. **Complejidad:** Jerarquías profundas de herencia pueden ser difíciles de mantener.
3. **Rigidez:** La herencia puede limitar la flexibilidad del diseño.

**Alternativa: Preferir Composición sobre Herencia.**

---

### **8. Composición**
**Definición:**
La **composición** es un principio que sugiere que los objetos deben estar compuestos por otros objetos en lugar de heredar de ellos. Es decir, "tiene un" en lugar de "es un".

**Ejemplo en Python:**
```python
class Motor:
    def encender(self):
        print("Motor encendido.")


class Coche:
    def __init__(self):
        self.motor = Motor()  # Composición

    def arrancar(self):
        self.motor.encender()
        print("Coche arrancado.")


coche = Coche()
coche.arrancar()
```

---

### **9. Beneficios de la Composición**
4. **Flexibilidad:** Es más fácil cambiar o reemplazar componentes individuales.
5. **Reutilización:** Los componentes pueden ser reutilizados en diferentes contextos.
6. **Simplicidad:** Evita jerarquías complejas de herencia.

---

### **Resumen Final**
| **Concepto**         | **Descripción**                                                                 |
|-----------------------|---------------------------------------------------------------------------------|
| **Encapsulamiento**   | Oculta los detalles internos y protege los datos.                              |
| **Abstracción**       | Simplifica el diseño al exponer solo lo esencial.                              |
| **Objeto/Clase**      | Un objeto es una instancia de una clase, que es una plantilla para crear objetos.|
| **Herencia**          | Permite reutilizar y extender el comportamiento de una clase.                  |
| **Polimorfismo**      | Permite que objetos diferentes respondan de manera distinta al mismo mensaje.  |
| **Composición**       | Combina objetos en lugar de heredar de ellos, mejorando la flexibilidad.       |

¡Espero que esta guía te sea útil para enseñar los conceptos de POO de manera clara y efectiva! 🚀
## ¿Qué es OOP?
- OPP es Object-Oriented Programming
- Requiere que el desarrollador piense en la solución del software de manera distinta
- Requiere el uso de un lenguaje orientado a objetos
## Beneficios de la Programación Orientada a Objetos (OO)

- Los objetos reflejan entidades reales del mundo real 
- Impulsa arquitectura, diseño y reusabilidad de código
- Promueve comunicación consistente en temas técnicos entre negocios y equipos técnicos
- Construye sistemas que son más fáciles de expandir o modificar
- Promueve soluciones de alta calidad
- Funciona para sistemas de software grandes y complejos
## Lenguajes orientados a OOP

- Java
- Python
- C++
- JavaScript - TypeScript
- C#

# Diseño para la OOP

[[S.O.L.I.D.]]

OOAD (Object-Oriented Analysis and Design)
Object-Oriented Analysis se enfoca en encontrar y describir objetos o conceptos en el dominio del problema

### OO (Orientado a Objetos) enfoque al diseño
- Definir y detallar los objetos perteneciente al software 
- Como interactúan los objetos del software para cumplir con los requisitos

#### Técnica de diseño
Las **tarjetas CRC** (Clase-Responsabilidad-Colaboración) son una técnica de diseño en la programación orientada a objetos, desarrollada por **Ward Cunningham** y **Kent Beck**. Esta metodología se utiliza para identificar y organizar las clases que formarán parte de un sistema, facilitando la comprensión y estructuración del mismo.

Cada tarjeta CRC representa una clase y se divide en tres secciones:

7. **Clase**: Nombre de la clase.
8. **Responsabilidad**: Funciones o comportamientos que la clase debe cumplir.
9. **Colaboración**: Otras clases con las que interactúa para cumplir sus responsabilidades.

Durante una sesión de diseño con tarjetas CRC, los participantes crean tarjetas para cada clase identificada y definen sus responsabilidades y colaboraciones. Este enfoque promueve una comprensión clara de cómo interactúan las diferentes partes del sistema y ayuda a detectar posibles problemas en la arquitectura antes de la implementación.

## Principios Clave de la Programación Orientada a Objetos

▸ La programación orientada a objetos se centra en los **objetos individuales y sus datos**.  
▸ Los sistemas orientados a objetos nos permiten ver un sistema como objetos que **encapsulan** estado y comportamiento.  
▸ Los modelos de diseño orientados a objetos se **desarrollan cerca de la implementación**. 
▸ Los sistemas orientados a objetos fomentan la **reutilización** de elementos de programación.

## Cualidades de un Sistema Orientado a Objetos (OO System)

### Reusabilidad
- Habilidad para crear y reutilizar componentes arquitectónicos de un sistema.
- Reducir la redundancia en el desarrollo al crear o adquirir framworks, componentes o servicios reutilizables.
- Los componentes pueden ser reutilizados en múiltiples proyectos.
- Aprovechar la experiencia de expertos en el dominio para la solución del desarrollo.
### Confiabilidad (Reliability)
Al reutilizar los componentes también disponemos de más tiempo para mantenerlos actualizados.
Los componentes están aislados de otros componentes del sistema. Por lo tanto al modificarlos no se afectan las otras piezas.
### Robustez 
La habilidad de un sistema para mantenerse operando correctamente bajo un rango de condiciones operacionales y fallar de manera controlada y anticipada en las condiciones fuera de tal rango.
El sistema debe ser capaz de funcionar a pesar de las condiciones.
El proceso de desarrollo OO está diseñado para que el equipo técnico desarrolle aplicaciones totalmente funcionales usando análisis preciso, diseño y técnicas de codificación
En tanto que el sistema evoluciona se debe aplicar testeo para verificar la robustez.
Se testea cada parte del sistema de manera desacoplada.
### Extensibilidad
La habilidad de añadir nuevos features (Características o funcionalidades) a un programa sin alterar código existente.
Esto se logra creando objetos modulares y componentes que pueden ser alterados o mejorados sin alterar otras partes de la aplicación.

### Mantenibilidad
La facilidad con la que cada sistema o componente puede ser modificado para corregir faltas, mejorar rendimiento o algún otro atributo. Así como adaptar a un ambiente que cambia.
Un buen diseño de OO permite modificar módulos sin afectar al sistema completo.


# Principios S.O.L.I.D.

Los **principios SOLID** son un conjunto de cinco principios de diseño en la programación orientada a objetos (POO) que buscan hacer que el software sea más **mantenible**, **escalable** y **flexible**. Estos principios fueron introducidos por **Robert C. Martin** (también conocido como "Uncle Bob") y son ampliamente utilizados en el desarrollo de software moderno.

A continuación, te explico cada uno de los principios SOLID con ejemplos claros:

---

### **1. S - Single Responsibility Principle (SRP)**  
**Principio de Responsabilidad Única**

**Definición:**  
Una clase debe tener una única razón para cambiar, es decir, debe tener una sola responsabilidad o tarea bien definida.

**Ejemplo:**
Imagina una clase `Informe` que genera un informe y lo guarda en un archivo:

```python
class Informe:
    def generar_informe(self, datos):
        return f"Informe: {datos}"

    def guardar_en_archivo(self, contenido, nombre_archivo):
        with open(nombre_archivo, 'w') as archivo:
            archivo.write(contenido)
```

**Problema:** La clase tiene dos responsabilidades: generar el informe y guardarlo en un archivo. Esto viola el SRP.

**Solución:** Dividir las responsabilidades en dos clases diferentes.

```python
class GeneradorInforme:
    def generar_informe(self, datos):
        return f"Informe: {datos}"

class GuardadorArchivo:
    def guardar_en_archivo(self, contenido, nombre_archivo):
        with open(nombre_archivo, 'w') as archivo:
            archivo.write(contenido)
```

Ahora cada clase tiene una única responsabilidad.

---

### **2. O - Open/Closed Principle (OCP)**  
**Principio de Abierto/Cerrado**

**Definición:**  
Las entidades de software (clases, módulos, funciones) deben estar **abiertas para extensión**, pero **cerradas para modificación**. Es decir, puedes agregar nuevas funcionalidades sin modificar el código existente.

**Ejemplo:**
Supongamos que tienes una clase `CalculadoraArea` que calcula el área de figuras geométricas:

```python
class CalculadoraArea:
    def calcular_area(self, figura):
        if figura == "circulo":
            return 3.14 * radio ** 2
        elif figura == "cuadrado":
            return lado ** 2
```

**Problema:** Si quieres agregar una nueva figura (por ejemplo, triángulo), necesitas modificar la clase existente, lo cual viola el OCP.

**Solución:** Usar herencia y polimorfismo.

```python
from abc import ABC, abstractmethod

class Figura(ABC):
    @abstractmethod
    def calcular_area(self):
        pass

class Circulo(Figura):
    def __init__(self, radio):
        self.radio = radio

    def calcular_area(self):
        return 3.14 * self.radio ** 2

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado

    def calcular_area(self):
        return self.lado ** 2

# Ahora puedes agregar nuevas figuras sin modificar la clase base.
```

---

### **3. L - Liskov Substitution Principle (LSP)**  
**Principio de Sustitución de Liskov**

**Definición:**  
Los objetos de una clase derivada (subclase) deben poder sustituirse por objetos de la clase base (superclase) sin alterar el comportamiento del programa.

**Ejemplo:**
Supongamos que tienes una clase `Ave` con un método `volar()`:

```python
class Ave:
    def volar(self):
        print("Volando...")

class Pinguino(Ave):
    def volar(self):
        raise Exception("Los pingüinos no pueden volar")
```

**Problema:** Al intentar usar un objeto `Pinguino` donde se espera un `Ave`, el programa fallará porque los pingüinos no vuelan.

**Solución:** Separar las responsabilidades.

```python
class Ave:
    pass

class AveVoladora(Ave):
    def volar(self):
        print("Volando...")

class AveNoVoladora(Ave):
    pass

class Pinguino(AveNoVoladora):
    pass
```

Ahora, los pingüinos no rompen el principio LSP porque no se espera que vuelen.

---

### **4. I - Interface Segregation Principle (ISP)**  
**Principio de Segregación de Interfaces**

**Definición:**  
Es mejor tener interfaces pequeñas y específicas en lugar de una interfaz grande y general. Los clientes no deben depender de interfaces que no usan.

**Ejemplo:**
Supongamos que tienes una interfaz `Trabajador` que incluye métodos como `trabajar()`, `comer()` y `dormir()`:

```python
class Trabajador:
    def trabajar(self):
        pass

    def comer(self):
        pass

    def dormir(self):
        pass
```

**Problema:** No todos los trabajadores comen o duermen en el trabajo (por ejemplo, robots).

**Solución:** Dividir la interfaz en interfaces más pequeñas.

```python
class Trabajador:
    def trabajar(self):
        pass

class Comedor:
    def comer(self):
        pass

class Durmiente:
    def dormir(self):
        pass
```

Ahora, cada clase puede implementar solo las interfaces que necesita.

---

### **5. D - Dependency Inversion Principle (DIP)**  
**Principio de Inversión de Dependencias**

**Definición:**  
Las clases de alto nivel no deben depender de clases de bajo nivel. Ambas deben depender de abstracciones. Además, las abstracciones no deben depender de detalles; los detalles deben depender de abstracciones.

**Ejemplo:**
Supongamos que tienes una clase `ControladorLuces` que depende directamente de una clase `Bombilla`:

```python
class Bombilla:
    def encender(self):
        print("Bombilla encendida")

class ControladorLuces:
    def __init__(self):
        self.bombilla = Bombilla()

    def operar(self):
        self.bombilla.encender()
```

**Problema:** Si quieres cambiar la bombilla por un LED, necesitas modificar la clase `ControladorLuces`.

**Solución:** Usar una interfaz abstracta.

```python
from abc import ABC, abstractmethod

class DispositivoEncendido(ABC):
    @abstractmethod
    def encender(self):
        pass

class Bombilla(DispositivoEncendido):
    def encender(self):
        print("Bombilla encendida")

class LED(DispositivoEncendido):
    def encender(self):
        print("LED encendido")

class ControladorLuces:
    def __init__(self, dispositivo: DispositivoEncendido):
        self.dispositivo = dispositivo

    def operar(self):
        self.dispositivo.encender()
```

Ahora, `ControladorLuces` depende de una abstracción (`DispositivoEncendido`) en lugar de una implementación específica.

---

### **Resumen de los Principios SOLID**

| **Principio** | **Significado**                                                                 |
|---------------|---------------------------------------------------------------------------------|
| **S**         | Una clase debe tener una única responsabilidad.                                |
| **O**         | Las clases deben ser abiertas para extensión, pero cerradas para modificación. |
| **L**         | Las subclases deben poder reemplazar a las superclases sin alterar el programa.|
| **I**         | Preferir interfaces pequeñas y específicas en lugar de interfaces grandes.     |
| **D**         | Depender de abstracciones, no de implementaciones.                             |

---

### **Beneficios de Aplicar SOLID**
1. **Mantenibilidad:** El código es más fácil de mantener y modificar.
2. **Escalabilidad:** Es más sencillo agregar nuevas funcionalidades sin romper el sistema.
3. **Reutilización:** Las clases y módulos son más reutilizables en diferentes contextos.
4. **Flexibilidad:** El sistema es más adaptable a cambios futuros.

# Conceptos básicos de la programación OO
- Objetos 
- Encapsulamiento
- Mensajes
- Abstracción
- Polimorfismo
- Herencia
Un software OO consiste en un grupo de objetos bien definidos que aprovechan la Encapsulamiento y se comunican entre ellos mediante mensajes.
### Objetos
- Entidad o concepto en la solución de software
- Bloques individuales de nuestra solución de software
- Tiene estados o datos (en forma de variables)
- Tiene un comportamiento (en forma de funciones)
- Es una instancia de un tipo de dato abstracto
 ![[Pasted image 20250207221931.png]]
### Abstracción
- Los objetos representan abstracciones de un concepto real y solo maneja datos y operaciones relevantes para nuestro caso de uso.
- Posibilidad de extensión en caso de ser necesaria.
### Herencia
- Podemos crear jerarquías de objetos donde las clases superiores manejan una base y sus herederas se especializan con nuevas y únicas características requeridas para el programa.
### Encapsulamiento 
- Empaquetar los datos con sus métodos correspondientes
- Técnica para ocultar datos
### Mensaje 
- Señal de un objeto hacia otro
- Petición hacia el objeto que recibe el mensaje para ejecutar un método
- Los lenguajes de programación utilizan funciones call
### Polimorfismo
- El mismo mensaje puede ser enviado a múltiples receptores y todos van a reaccionar según su programación de manera única

# Contraste de la metodología OO con la metodología estructurada - Visión general
![[Pasted image 20250207224035.png]]
![[Pasted image 20250207225121.png]]
![[Pasted image 20250207225200.png]]

![[Pasted image 20250207225222.png]]
![[Pasted image 20250207225246.png]]

![[Pasted image 20250207225318.png]]
![[Pasted image 20250207224552.png]]

# Cuestionario
![[Pasted image 20250207224915.png]]![[Pasted image 20250207224932.png]]![[Pasted image 20250207225007.png]]
![[Pasted image 20250207225500.png]]
